generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums - MODIFIÉ: Ajout de PATIENT
enum UserRole {
  ADMIN
  DOCTOR
  NURSE
  RECEPTIONIST
  PATIENT        // NOUVEAU
}

enum InvoiceStatus {
  DRAFT
  PENDING
  PAID
  CANCELLED
  OVERDUE
}

enum AppointmentStatus {
  SCHEDULED
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

// MODIFIÉ: User peut maintenant être un Patient aussi
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String
  name          String?
  firstName     String?
  lastName      String?
  phone         String?
  image         String?
  role          UserRole  @default(PATIENT)  // MODIFIÉ: Par défaut PATIENT
  
  // Champs pour le staff (Admin, Doctor, Nurse, Receptionist)
  clinicId      String?
  tenantId      String?
  tenantName    String?
  
  // NOUVEAU: Champs spécifiques pour Médecins
  specialization String?
  licenseNumber  String?
  
  // NOUVEAU: Champs spécifiques pour Patients
  dateOfBirth    DateTime?
  gender         String?
  address        String?
  city           String?
  postalCode     String?
  emergencyContact String?
  emergencyPhone   String?
  bloodType      String?
  allergies      String?
  medicalHistory String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // NOUVEAU: Relations pour les patients
  invoicesAsPatient     Invoice[]      @relation("PatientInvoices")
  appointmentsAsPatient Appointment[]  @relation("PatientAppointments")
  consultationsAsPatient Consultation[] @relation("PatientConsultations")
  
  @@index([email])
  @@index([role])
}

// MODIFIÉ: Patient devient optionnel (les données sont dans User)
model Patient {
  id               String   @id @default(cuid())
  firstName        String
  lastName         String
  email            String?
  phone            String
  dateOfBirth      DateTime
  gender           String
  address          String?
  city             String?
  postalCode       String?
  emergencyContact String?
  emergencyPhone   String?
  bloodType        String?
  allergies        String?
  medicalHistory   String?
  tenantId         String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  invoices         Invoice[]
  appointments     Appointment[]
  consultations    Consultation[]
}

model Appointment {
  id        String   @id @default(cuid())
  
  // Support à la fois Patient model et User (patient)
  patientId String?
  patient   Patient?  @relation(fields: [patientId], references: [id])
  
  userPatientId String?
  userPatient   User?    @relation("PatientAppointments", fields: [userPatientId], references: [id])
  
  doctorId  String
  date      DateTime
  time      String
  status    AppointmentStatus @default(SCHEDULED)
  type      String   @default("CHECKUP")
  reason    String?
  notes     String?
  tenantId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([patientId])
  @@index([userPatientId])
  @@index([doctorId])
}

model Consultation {
  id            String   @id @default(cuid())
  
  // Support à la fois Patient model et User (patient)
  patientId     String?
  patient       Patient?  @relation(fields: [patientId], references: [id])
  
  userPatientId String?
  userPatient   User?     @relation("PatientConsultations", fields: [userPatientId], references: [id])
  
  doctorId      String
  diagnosis     String
  symptoms      String
  notes         String?
  prescription  String?
  tenantId      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([patientId])
  @@index([userPatientId])
}

model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique @default(cuid())
  
  // Support à la fois Patient model et User (patient)
  patientId     String?
  patient       Patient?       @relation(fields: [patientId], references: [id])
  
  userPatientId String?
  userPatient   User?          @relation("PatientInvoices", fields: [userPatientId], references: [id])
  
  amount        Float
  status        InvoiceStatus @default(PENDING)
  dueDate       DateTime
  description   String?
  discount      Float?
  tax           Float?
  notes         String?
  tenantId      String?
  stripeId      String?
  paidAt        DateTime?
  items         InvoiceItem[]
  payments      Payment[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  
  @@index([patientId])
  @@index([userPatientId])
}

model InvoiceItem {
  id          String   @id @default(cuid())
  invoiceId   String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])
  description String
  quantity    Int
  unitPrice   Float
  total       Float
}

model Payment {
  id        String        @id @default(cuid())
  invoiceId String
  invoice   Invoice       @relation(fields: [invoiceId], references: [id])
  amount    Float
  status    PaymentStatus @default(PENDING)
  stripeId  String?
  method    String?
  tenantId  String?
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
}